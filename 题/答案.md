1.md
1.// 输出
undefined
ReferenceError: b is not defined
2.// 输出
ReferenceError: Cannot access 'a' before initialization
3.// 输出
2 1
undefined {n: 2}
4.// 输出 
function c(a){
    console.log(a);
    var a = 3;
    function a(){
    }
}

function a(){
}
复制代码变量提升也有优先级, 函数声明 > arguments > 变量声明
5.//  输出
1
TypeError: c is not a function
由于函数声明会提升,当函数外的console.log(c)执行时,c已经被赋值为1。因此,执行c(2)时会抛出TypeError,因为1不是函数。

6、// 输出 
chen

自执行函数执行时,会先进行变量提升(这里涉及到执行上下文不过多说,一定要搞懂执行上下文),在自执行函数执行时,伪代码为:
var name = 'erdong';
(function () {
    var name;  // 变量name会提升到当前作用域顶部
    if (typeof name === 'undefined') {
        name = 'chen'
        console.log(name)
    } else {
        console.log(name)
    }
})();

7、// 输出
100
10
100
test()为函数独立调用,作用域中的this绑定为全局对象window。
test函数执行时,var a被提升到了作用域顶部,因此函数作用域中存在一个变量a。所以在函数中访问的a都是局部作用域中的a。

100 100

90 10

8、// 输出
undefined
由于if后的{}不会产生块级作用域(不包含let,const时),此时的伪代码为:
var a;
if (!(a in window)) {
    a = 1;
}
console.log(a);
var a相当于window.a。因此!(a in window)转成布尔值为false,不会执行a = 1。所有console.log(a)输出undefined。

9、//输出  跟第4题类似
undefined 
2

10、// 输出
obj(指向的值)
1

11、// 输出
erdong
object.getNameFunc()(),先执行object.getNameFunc()返回一个函数:
function () {
    return this.name;
}
返回的函数再执行,相当于
(function () {
    return this.name;
})();
此时的this绑定为window。因此输出全局变量name的值erdong。

12、//输出
chen
object.getNameFunc()执行时,此时getNameFunc中的this绑定为object,因此that = object。object.getNameFunc()返回的函数再执行时,产生闭包,因此返回的函数也能访问到外层作用域中的变量that,因此object.name为object.name,即 chen。



