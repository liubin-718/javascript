1、loader的实现原理，自己有无实现一个loader？
一个Loader的职责是单一的，只需要完成一种转换。
一个Loader其实就是一个Node.js模块，这个模块需要导出一个函数。
loader就是一个函数，这个函数对源文件进行增删改处理，将处理好的结果返回给webpack。
https://www.jianshu.com/p/c021b78c9ef2

2、webpack打包原理？
3、vue生命周期钩子在源码哪里实现的？
4、flex:0 1 auto代表什么？
5、比如：用echarts绘图类项目，一次前端向后台请求大量的数据，前台该怎么处理？

6、es6中有哪些数组去重方法？
    a.用map结构
    function unquire(arr){
      const res = new Map()
      return res.filter((v)=>!res.has(v) && res.set(v,1))
    }
    b.利用Array.from和set
    function unique(arr){
        //通过Set对象，对数组去重，结果返回一个Set对象
        //通过from方法，将Set对象转为数组
        return Array.from(new Set(arr))
    }
    c. set和...扩展运算符
    [...new Set(arr)]

7、map和set？
集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组
ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值
在数据结构还有一种结构叫做字典，它就是实现基于ES6中的Map类的结构
那么集合又和字典有什么区别呢：

共同点：集合、字典可以存储不重复的值
不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储

所以这一下让我们明白了，Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“值—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适
链接：https://juejin.im/post/5acc57eff265da237f1e9f7c

8、判断数组的方法？
  -arr instanceof Array
  -arr.constructor === Array
  -Object.prototype.toString.call(arr) === '[object Array]'
  -Array.isArray(arr)
9、如何在网页上实现大数据可视化渲染？
https://www.bilibili.com/video/av68731664
https://github.com/Ovilia?tab=repositories

10、require和import区别？
首先这两个都是为了JS模块化编程使用.
CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

遵循规范
require 是 AMD规范引入方式
import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法
调用时间
require是运行时调用，所以require理论上可以运用在代码的任何地方（虽然这么说但是还是一般放开头）
import是编译时调用，所以必须放在文件开头
本质
require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量
import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require

11、babel的实现原理？
babel 的转译过程也分为三个阶段，这三步具体是：
解析 Parse: 将代码解析⽣成抽象语法树( 即AST )，即词法分析与语法分析的过程 转换 Transform: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在 此过程中进⾏添加、更新及移除等操作 ⽣成 Generate: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator
更具体的原理可以移步如何写⼀个babel
如何写⼀个babel插件?
Babel解析成AST，然后插件更改AST，最后由Babel输出代码
那么Babel的插件模块需要你暴露⼀个function，function内返回visitor

12、父组件的created和子组件的mounted的执行先后问题，为什么？  -------------------------------

13、Vue-Router实现原理？  -----> 问题延伸：vuex实现原理？
https://juejin.im/post/6844903612930326541
14、vue 更改属性值，或将初始值v-if=false在method中置为true时，vue发生了什么过程 （源码角度）
15、浏览器缓存
https://www.josephxia.com/document/node/cache/HTTP%E7%BC%93%E5%AD%98.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98
16、Vue.set和vue.$set原理
https://juejin.cn/post/6844903830837002253

17、谈谈commonjs、cmd、umd、es6模块
https://juejin.cn/post/6844904029454073864
commonjs  同步加载  对模块的浅拷⻉
  -模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后就直接读取缓存结果
  -CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值
amd    异步模块 requirejs    可以并行加载多个模块
  -1.模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
  -2.导入和使用模块
    require([module], callback)
    第二个参数[module]，是一个数组，里面的成员就是要加载的模块
    第二个参数callback，则是加载成功之后的回调函数
  -3.依赖前置：必须等到所有依赖的模块加载完成之后才会执行回调，即使在回调里根本没用到该模块。
          （在定义模块的时候就要声明其依赖的模块），不过目前在AMD2.0也可以动态加载模块了
cmd   通用模块定义 seajs  跟requireJS解决同样问题，只是运行机制不同
  -优点： 同样实现了浏览器端的模块化加载。 可以按需加载，依赖就近。
  AMD在加载完成定义（define）好的模块就会立即执行，所有执行完成后，遇到require才会执行主逻辑。（提前加载）
  CMD在加载完成定义（define）好的模块，仅仅是下载不执行，在遇到require才会执行对应的模块。（按需加载）
  AMD用户体验好，因为没有延迟，CMD性能好，因为只有用户需要的时候才执行。
  CMD为什么会出现，因为对node.js的书写者友好，因为符合写法习惯，就像为何vue会受人欢迎的一个道理。
es6
  -ES6模块中的值属于【动态只读引用】。
    对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
  -对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。
  -循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。




18、vuex和EventBus原理
<inpupt :value='v' @input='v=$event.target.value'/>
19、react哪些钩子有安全问题？为什么
20、JavaScript的作⽤域链理解吗？✨
JavaScript属于静态作⽤域，即声明的作⽤域是根据程序正⽂在编译时就确定的，有时也称为词法作⽤域。
其本质是JavaScript在执⾏过程中会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们 可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了作⽤域 链。
【原型链】
原因是每个对象都有 proto 属性，此属性指向该对象的构造函数的原型。 对象可以通过 proto 与上游的构造函数的原型对象连接起来，⽽上游的原型对象也有⼀个 proto ，这样就形成 了原型链。

21、this
绑定优先级: new绑定 > 显式绑定 >隐式绑定 >默认绑定

  1）显示改变this指向，常⻅的⽅法就是call、apply、bind
  2）箭头函数不同于传统JavaScript中的函数,箭头函数并没有属于⾃⼰的this,它的所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值,并且由于没有属于⾃⼰的this,⽽箭头函数是不会被new调⽤的，这个所谓的this也不会被改变

async/await相⽐于Promise的优势？
代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀ 个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪 同步代码的『每⼀步』。
